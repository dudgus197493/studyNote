#include<stdio.h>
int Test(int* a) {
	*a = 500;
	return 0;
}

int main() {



	// 포인터 변수
	// 주소를 저장하는 변수
	// 자료형 + * 변수명
	// 포인터변수에서의 자료형 : 해당 포인터에게 전달된 주소를 해석하는 단위
	/*int i = 100;
	int* pInt = &i;*/ // int* 주소를 저장하는 변수를 선언(포인터)
	// ㄴ> 주소를 저장하는데 넣을때 int형 데이터의 주소만 넣어라
	// ㄴ> 자기가 가리킬 데이터의 타입을 정해놓음
// %i 자신의 주소값을 반환

// float f = 3.f;		
// int* pFloat = &f;	포인터 변수가 가르키고자 하는 데이터의 사이즈는 4바이트로 같으나 실수, 정수의 표현방식이 다름
						// 컴파일 오류 발생
/*(*pInt) = 100;*/	// *pInt 자신에게 저장되어있는 주소로 접근
/*printf("i의 값 %d", i);*/

// 주소의 최소 단위 : BYTE
// 포인터 변수의 크기는 64비트 운영체제 기준 8바이트다.
// 주소를 표현하는 타입 : 정수 -> 비트 단위로는 보유할 수 없음.
// ex) 100과 102의 주소값 사이에는 2의 차이가 있다.

/*float f = 3.f;
int* pInt = (int*)&f;

i = *pInt;

printf("i의 값은 %d", i);
	엄청 큰 값이 나옴
	f의 주소 안에 있는 값이 float형으로 저장되어있는데
	int* 포인트 변수는 자신한테 저장되어있는 변수에 접근했을때
	int 형으로 4byte읽으므로 엄청나게 큰 값이 저장됨
		ㄴ> 메모리 안에있는 값은 똑같은데
			그 값을 어떻게 볼건지에 따라서 값이 달라짐
*/


// 포인터 변수
// 보통의 변수 선언 : 자료형 + 변수명

	int* pInt = nullptr;
	int i = 0;
	pInt = &i;

	//포인터의 연산은 정수와 다르다 주소 100을 저장하는 포인터변수에 1을 더하면 101이 아니라, 104 가됨
	//ex) int형 포인터에게 다음이라는 것은 다음 가리키는 int형 변수의 주소를 가르키기 위해 움직임
	// 그래서 위 코드에서 주소100 변수에 +1을하면 int자료형의 크기인 4byte증가된 104의 주소를 가리킴
	pInt += 1;
	//pInt 는 int* 변수 이기 때문에, 가리키는 곳을 int로 해석한다.
	//따라서 주소값을 1증가하는 의미는 다음 int 위치로 접근하기 위해서 sizeof(int) 단위로 증가하게 된다.



	// 포인터와 배열
	// 배열의 특징
	// 1. 메모리가 연속적인 구조이다.
	// 2. 배열의 이름은 배열의 시작 주소이다.

	int iArr[10] = {}; // iArr = 배열의 시작 주소
	// int 단위(4byte)
	*(iArr + 0) = 10; // iArr[0] = 10;	배열의 수식의 비밀
	*(iArr + 1) = 10; // iArr[1] = 10;

	// 포인터 이해 확인 문제
	// 문제 1.
	//short sArr[10] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10 };

	//int* pI = (int*)sArr;

	//int iData1 = *((short*)(pI + 2));

	//printf("1번 문제 정답 : %d\n", iData1);
	//
	//// 문제 2.
	//char cArr[2] = { 1, 1 };

	//short* pS = (short*)cArr;

	//int iData2 = *pS;

	//printf("2번 문제 정답 : %d\n", iData2);
	int a = 100;
	
	Test(&a); // 포인터를 쓰는이유 중 하나
			  // 호출받은 함수는 호출한 함수의 지역변수를 모르기때문에 직접적인 변경이 불가능
			  // 호출한 함수의 지역변수주소값을 전달하여 호출받은 함수안에서 값을 변경할 수 있도록 함.

	printf("출력 : %d", a);

	/*scanf_s("%d", &a);*/

	return 0;
}
	
	
